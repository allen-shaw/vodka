package template

import (
	"bytes"
	_ "embed"
	"fmt"
	"strings"
	"text/template"

	"github.com/allen-shaw/vodka/cmd/vodka/internal/protobuf/log"
	"github.com/allen-shaw/vodka/cmd/vodka/internal/util"
	"github.com/allen-shaw/vodka/cmd/vodka/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
)

// templates
var (
	//go:embed server.tpl
	serverTpl string

	//go:embed api.tpl
	apiTpl string

	//go:embed router.tpl
	routerTpl string

	//go:embed service.tpl
	serviceTpl string
)

// 文件名
const (
	serverFileName        = "sever_gen.go"
	routerFileName        = "router_gen.go"
	serviceFileNameSuffix = "_gin.pb.go"
)

// import pkg
type Import struct {
	Alias string
	Path  protogen.GoImportPath
}
type Imports []*Import

func (i Imports) Export() []protogen.GoImportPath {
	ips := make([]protogen.GoImportPath, 0, len(i))
	for _, ip := range i {
		gip := ip.Path
		ips = append(ips, gip)
	}
	return ips
}

const (
	contextPkg = protogen.GoImportPath("context")
	errorsPkg  = protogen.GoImportPath("errors")
	netHttpPkg = protogen.GoImportPath("net/http")
	ginPkg     = protogen.GoImportPath("github.com/gin-gonic/gin")
)

// 文件所属pkg
const (
	PkgInternal = "internal"
)

// 一些常量
const (
	commentTpl = `// Code generated by protoc-gen-go-gin. DO NOT EDIT.
// versions:
// 	protoc-gen-go-gin %v
// 	protoc        	  %v
// source: %v`
)

func GetComment(protocVersion string, source ...string) string {
	src := strings.Join(source, ",")
	return fmt.Sprintf(commentTpl, version.Version, protocVersion, src)
}

// vodka
var (
	apiPkgPrefix   = "github.com/allen-shaw/vodka/demo/internal/api/"
	modelPkgPrefix = "github.com/allen-shaw/vodka/demo/internal/model/api"
	apiDirPrefix   = "internal/api/"
	internalDir    = "internal"
)

// 1. 生成api -> ./internal/api/${serviceShortName}/${service_name}.go  // 允许用户修改
type ApiGenerator struct {
	Pkg      protogen.GoPackageName
	dir      string
	fileName string
	Imports  Imports
	Service  *Service
	gen      *protogen.Plugin
}

func NewApiGenerator(gen *protogen.Plugin, vodka bool, service *Service) *ApiGenerator {
	if !vodka {
		// 非vodka不生成api
		return nil
	}

	pkg := protogen.GoPackageName(service.Prefix)
	dir := apiDirPrefix + string(pkg)
	fileName := util.SnakeCase(service.Name) + ".go"
	imports := make(Imports, 0)
	imports = append(imports, &Import{Path: ginPkg})
	imports = append(imports, &Import{
		Alias: "api",
		Path:  protogen.GoImportPath(modelPkgPrefix + string(pkg)),
	})

	g := &ApiGenerator{
		Pkg:      pkg,
		dir:      dir,
		fileName: fileName,
		Imports:  imports,
		Service:  service,
		gen:      gen,
	}
	log.Debug("NewApiGenerator:%+v\n", g)

	return g
}

func (g *ApiGenerator) Gen() {
	if g == nil {
		return
	}

	gf := g.gen.NewGeneratedFile(g.fileName, protogen.GoImportPath(g.Pkg))
	gf.P(g.execute())
}

func (g *ApiGenerator) execute() string {
	return execute(g, apiTpl)
}

func execute(data any, tpl string) string {
	buf := new(bytes.Buffer)
	tmpl, err := template.New("http").Parse(strings.TrimSpace(tpl))
	if err != nil {
		panic(err)
	}
	if err := tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	log.Debug("111111 %+v , tpl %+v, data %+v\n", buf.String(), tpl, data)
	return buf.String()
}

///////////////

type ServiceGenerator struct {
	Comment  string
	Pkg      protogen.GoPackageName
	dir      string
	fileName string
	Imports  []*Import
	Service  *Service
	gen      *protogen.Plugin
}

func NewServiceGenerator(gen *protogen.Plugin, vodka bool, service *Service) *ServiceGenerator {
	if !vodka {
		// 非vodka不生成api
		return nil
	}

	protocVersion := getProtocVersion(gen)
	protocFiles := make([]string, 0, len(gen.Files))
	protocFiles = append(protocFiles, *service.ProtoFile.Proto.Name)

	comment := GetComment(protocVersion, protocFiles...)
	pkg := protogen.GoPackageName(PkgInternal)
	dir := internalDir
	fileName := util.SnakeCase(service.Prefix) + serviceFileNameSuffix
	imports := make([]*Import, 0)

	imports = append(imports, &Import{Path: errorsPkg})
	imports = append(imports, &Import{Path: netHttpPkg})
	imports = append(imports, &Import{
		Path: protogen.GoImportPath(apiPkgPrefix + string(pkg)),
	})
	imports = append(imports, &Import{Path: ginPkg})
	imports = append(imports, &Import{
		Alias: "api",
		Path:  protogen.GoImportPath(modelPkgPrefix + string(pkg)),
	})

	return &ServiceGenerator{
		Comment:  comment,
		Pkg:      pkg,
		dir:      dir,
		fileName: fileName,
		Imports:  imports,
		Service:  service,
		gen:      gen,
	}
}

func (g *ServiceGenerator) Gen() {
	if g == nil {
		return
	}
	gf := g.gen.NewGeneratedFile(g.fileName, protogen.GoImportPath(g.Pkg))
	gf.P(g.execute())
}

func (g *ServiceGenerator) execute() string {
	return execute(g, serviceTpl)
}

type RouterGenerator struct {
	Pkg      protogen.GoPackageName
	dir      string
	fileName string
	Imports  []*Import
	Server   *Server
	gen      *protogen.Plugin
}

func NewRouterGenerator(gen *protogen.Plugin, vodka bool, s *Server) *RouterGenerator {
	if !vodka {
		return nil
	}

	pkg := protogen.GoPackageName(PkgInternal)
	dir := internalDir
	fileName := routerFileName
	imports := make([]*Import, 0)
	imports = append(imports, &Import{Path: ginPkg})
	return &RouterGenerator{
		Pkg:      pkg,
		dir:      dir,
		fileName: fileName,
		Imports:  imports,
		Server:   s,
		gen:      gen,
	}
}

func (g *RouterGenerator) Gen() {
	if g == nil {
		return
	}

}

type ServerGenerator struct {
	Pkg      protogen.GoPackageName
	dir      string
	fileName string
	Imports  []*Import
	Server   *Server
	gen      *protogen.Plugin
}

func NewServerGenerator(gen *protogen.Plugin, vodka bool, s *Server) *ServerGenerator {
	if !vodka {
		return nil
	}

	pkg := protogen.GoPackageName(PkgInternal)
	dir := internalDir
	fileName := serverFileName
	imports := make([]*Import, 0)
	imports = append(imports, &Import{Path: ginPkg})
	return &ServerGenerator{
		Pkg:      pkg,
		dir:      dir,
		fileName: fileName,
		Imports:  imports,
		Server:   s,
		gen:      gen,
	}
}

func (g *ServerGenerator) Gen() {
	if g == nil {
		return
	}
}

func getProtocVersion(gen *protogen.Plugin) string {
	v := *gen.Request.GetCompilerVersion()
	return fmt.Sprintf("v%v.%v.%v", *v.Major, *v.Minor, *v.Patch)
}
